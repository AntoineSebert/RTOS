@article{Belady1966,
abstract = {One of the basic limitations of a digital computer is the size of its available memory.1 In most cases, it is neither feasible nor economical for a user to insist that every problem program fit into memory. The number of words of information in a program often exceeds the number of cells (i.e., word locations) in memory. The only way to solve this problem is to assign more than one program word to a cell. Since a cell can hold only one word at a time, extra words assigned to the cell must be held in external storage. Conventionally, overlay techniques are employed to exchange memory words and external-storage words whenever needed; this, of course, places an additional planning and coding burden on the programmer. For several reasons, it would be advantageous to rid the programmer of this function by providing him with a “virtual” memory larger than his program. An approach that permits him to use a sufficiently large address range can accomplish this objective, assuming that means are provided for automatic execution of the memory-overlay functions.},
author = {Belady, L. A.},
doi = {10.1147/sj.52.0078},
isbn = {0018-8670},
issn = {0018-8670},
journal = {IBM Systems Journal},
title = {{A study of replacement algorithms for a virtual-storage computer}},
year = {1966}
}
@inproceedings{Dijkstra1967,
abstract = {A multiprogramming system is described in which all activities are divided over a number of sequential processes. These sequential processes are placed at various hierarchical levels, in each of which one or more independent abstractions have been implemented. The hierarchical structure proved to be vital for the verfication of the logical soundness of the design and the correctness of its implementation.},
author = {Dijkstra, Edsger W.},
booktitle = {Proceedings of the ACM symposium on Operating System Principles  - SOSP '67},
doi = {10.1145/800001.811672},
isbn = {0-387-95401-5},
issn = {00010782},
pmid = {19633296},
title = {{The structure of the “the”-multiprogramming system}},
year = {1967}
}
@inproceedings{kleinrock1970contiuum,
author = {Kleinrock, Leonard},
booktitle = {Proceedings of the May 5-7, 1970, spring joint computer conference},
organization = {ACM},
pages = {453--458},
title = {{A contiuum of time-sharing scheduling algorithms}},
year = {1970}
}
@article{denning1970virtual,
author = {Denning, Peter J},
journal = {ACM Computing Surveys (CSUR)},
number = {3},
pages = {153--189},
publisher = {ACM},
title = {{Virtual memory}},
volume = {2},
year = {1970}
}
@article{Hansen1970,
abstract = {This paper describes the philosophy and structure of a multiprogramming system that can be extended with a hierarchy of operating systems to suit diverse requirements of program scheduling and resource allocation. The system nucleus simulates an environment in which program execution and input/output are handled uniformly as parallel, cooperating processes. A fundamental set of primitives allows the dynamic creation and control of a hierarchy of processes as well as the communication among them.},
author = {Hansen, Per Brinch},
doi = {10.1145/362258.362278},
issn = {00010782},
journal = {Communications of the ACM},
title = {{The nucleus of a multiprogramming system}},
year = {1970}
}
@article{Liu1973,
abstract = {The problem of multiprogram scheduling on a single processor is studied from the viewpoint of the characteristics peculiar to the program functions that need guaranteed ser- vice. It is shown that an optimum fixed priority scheduler possesses an upper bound to proces- sor utihzation which may be as low as 70 percent for large task sets. It is also shown that full processor utilization can be achieved by dynamically assigning priorities on the basis of their current deadhnes. A combination of these two scheduling techmques is also discussed.},
author = {Liu, C. L. and Layland, James W.},
doi = {10.1145/321738.321743},
isbn = {0-8186-0819-6},
issn = {00045411},
journal = {Journal of the ACM},
pmid = {28674844},
title = {{Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment}},
year = {1973}
}
@article{Carr1981,
abstract = {Camera network systems generate large volumes of potentially useful data, but extracting value from multiple, related videos can be a daunting task for a human reviewer. Multicamera video summarization seeks to make this task more tractable by generating a reduced set of output summary videos that concisely capture important portions of the input set. We present a system that approaches summarization at the level of detected activity motifs and shortens the input videos by compacting the representation of individual activities. Additionally, redundancy is removed across camera views by omitting from the summary activity occurrences that can be predicted by other occurrences. The system also detects anomalous events within a unified framework and can highlight them in the summary. Our contributions are a method for selecting useful parts of an activity to present to a viewer using activity motifs and a novel framework to score the importance of activity occurrences and allow transfer of importance between temporally related activities without solving the correspondence problem. We provide summarization results for a two camera network, an eleven camera network, and data from PETS 2001. We also include results from Amazon Mechanical Turk human experiments to evaluate how our visualization decisions affect task performance.},
author = {Carr, Richard W. and Hennessy, John L.},
doi = {10.1145/1067627.806596},
isbn = {0-89791-062-1},
issn = {01635980},
journal = {ACM SIGOPS Operating Systems Review},
title = {{WSCLOCK---a simple and effective algorithm for virtual memory management}},
year = {1981}
}
@article{Rashid1988,
abstract = {Recent technological advances in memory management architectures, multiprocessor systems, and software architectures dictate a reevaluation of the virtual memory management support provided by an operating system. The problems posed by multiprocessor systems and the portability issues raised by the large variety of memory management units available have not been satisfactorily addressed by past virtual memory systems. In addition, increases in virtual memory functionality that can be provided by memory managed architectures have gone largely unnoticed by system designers. This paper describes the design, implementation, and evaluation of the Mach virtual memory management system. The Mach virtual memory system exhibits architecture indepedence, multiprocessor and distributed system support, and advanced functionality. The performance of this virtual memory system is shown to often exceed that of commercially developed memory management systems targeted at specific hardware architectures.},
author = {Rashid, Richard and Young, Michael and Golub, David and Baron, Robert and Black, David and Chew, Jonathan and Tevanian, Avadis and Bolosky, William J.},
doi = {10.1109/12.2242},
isbn = {0-8186-0805-6},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Architecture independence,Mach,UNIX,parallel operating systems,virtual memory},
title = {{Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures}},
year = {1988}
}
@article{LARRYL.PETERSONNICKC.BUCHHOLZ1989,
abstract = {When processes in a network communicate, the messages they exchange define a partial ordering of externally visible events. While the significance of this partial order in distributed computing is well understood, it has not been made an explicit part of the communication substrate upon which distributed programs are implemented. This paper describes a new interprocess communication mechanism, called Psync, that explicitly encodes this partial ordering with each message. The paper shows how Psync can be efficiently implemented on an unreliable communications network, and it demonstrates how conversations serve as an elegant foundation for ordering messages exchanged in a distributed computation and for recovering from processor failures.},
author = {{LARRY L. PETERSON, NICK C. BUCHHOLZ}, and RICHARD D. SCHLICHTING},
doi = {10.1145/65000.65001},
issn = {07342071},
journal = {ACM Transactions on Computer Systems},
title = {{Preserving and Using Context Information in Interprocess Communication}},
year = {1989}
}
@article{stankovic1989spring,
author = {Stankovic, John A and Ramamritham, Krithi},
journal = {ACM SIGOPS Operating Systems Review},
number = {3},
pages = {54--71},
publisher = {ACM},
title = {{The Spring kernel: a new paradigm for real-time operating systems}},
volume = {23},
year = {1989}
}
@inproceedings{abrossimov1989generic,
author = {Abrossimov, E and Rozier, Marc and Shapiro, Marc},
booktitle = {ACM SIGOPS Operating Systems Review},
number = {5},
organization = {ACM},
pages = {123--136},
title = {{Generic virtual memory management for operating system kernels}},
volume = {23},
year = {1989}
}
@inproceedings{mishra1989implementing,
author = {Mishra, Shivakant and Peterson, Larry L and Schlichting, Richard D},
booktitle = {Reliable Distributed Systems, 1989., Proceedings of the Eighth Symposium on},
organization = {IEEE},
pages = {42--52},
title = {{Implementing fault-tolerant replicated objects using Psync}},
year = {1989}
}
@inproceedings{10.1007/978-1-4471-3860-0_19,
abstract = {How should time be represented in models for inter-process communication? The global-time axiom implies that all events can be represented by intervals on one time-axis. Its use simplifies the analysis of protocols and allows for intuitive proofs of their properties. On the other hand,some researchers believe it is too strong an assumption which should be avoided. In order to suggest an answer to this question we study the notion of a system-execution introduced by Lamport. We develop a practical tool which enables the investigation of protocols and allows for intuitive proofs of their properties. We apply our approach to prove that in many cases the global time axiom can be safely used. The main mathematical tool we employ is the theory of interval partial orders and we prove some new results along a line that goes back to the work of Russell and Wiener.},
address = {London},
author = {Abraham, Uri and Ben-David, Shai and Magidor, Menachem},
booktitle = {Semantics for Concurrency},
isbn = {978-1-4471-3860-0},
pages = {311--323},
publisher = {Springer London},
title = {{On Global-Time and Inter-process Communication}},
year = {1990}
}
@article{Sha1990,
abstract = {An investigation is conducted of two protocols belonging to the$\backslash$npriority inheritance protocols class; the two are called the basic$\backslash$npriority inheritance protocol and the priority ceiling protocol. Both$\backslash$nprotocols solve the uncontrolled priority inversion problem. The$\backslash$npriority ceiling protocol solves this uncontrolled priority inversion$\backslash$nproblem particularly well; it reduces the worst-case task-blocking time$\backslash$nto at most the duration of execution of a single critical section of a$\backslash$nlower-priority task. This protocol also prevents the formation of$\backslash$ndeadlocks. Sufficient conditions under which a set of periodic tasks$\backslash$nusing this protocol may be scheduled is derived},
author = {Sha, Lui and Rajkumar, Ragunathan and Lehoczky, John P.},
doi = {10.1109/12.57058},
isbn = {0018-9340},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Priority inheritance,priority inversion,realtime systems,scheduling,synchronization},
title = {{Priority Inheritance Protocols: An Approach to Real-Time Synchronization}},
year = {1990}
}
@inproceedings{Hildebrand1992,
abstract = {This paper presents an architectural overview of the QNX operating system. QNX is an OS that provides applications with a fully network- and multi- processor-distributed, realtime environment that delivers nearly the full, device-level performance of the underlying hardware. The OS architecture used to deliver this operating environment is that of a realtime microkernel surrounded by a collection of optional processes that provide POSIX- and UNIX-compatible system services. By including or excluding various resource managers at run time, QNX can be scaled down for ROM-based embedded systems, or scaled up to encompass hundreds of processors— either tightly or loosely connected by various LAN technologies. Confor- mance to POSIX standard 1003.1, draft standard 1003.2 (shell and utilities) and draft standard 1003.4 (realtime) is maintained transparently throughout the distributed environment.},
author = {Hildebrand, Dan},
booktitle = {Workshop on Micro-kernels and Other Kernel Architectures},
doi = {10.2307/2981886},
isbn = {1880446421},
issn = {00359238},
keywords = {Architecture,Device-level,Overview},
title = {{An Architectural Overview of QNX{\{}{\textregistered}{\}}}},
year = {1992}
}
@inproceedings{ONeil1993,
abstract = {This paper introduces a new approach to database disk buffering, called the LRU-K method. The basic idea of LRU-K is to keep track of the times of the last K references to popular database pages, using this information to statistically estimate the interarrival times of references on a page by page basis. Although the LRU-K approach performs optimal statistical inference under relatively standard assumptions, it is fairly simple and incurs little bookkeeping overhead. As we demonstrate with simulation experiments, the LRU-K algorithm surpasses conventional buffering algorithms in discriminating between frequently and infrequently referenced pages. In fact, LRU-K can approach the behavior of buffering algorithms in which page sets with known access frequencies are manually assigned to different buffer pools of specifically tuned sizes. Unlike such customized buffering algorithms however, the LRU-K method is self-tuning, and does not rely on external hints about workload characteristics. Furthermore, the LRU-K algorithm adapts in real time to changing patterns of access.},
author = {O'Neil, Elizabeth J and O'Neil, Patrick E and Weikum, Gerhard},
booktitle = {Proceedings of the 1993 ACM SIGMOD international conference on Management of data},
doi = {10.1145/170036.170081},
isbn = {0-89791-592-5},
issn = {01635808},
pmid = {19023351},
title = {{The LRU-K page replacement algorithm for database disk buffering}},
year = {1993}
}
@inproceedings{Rajkumar1995,
abstract = {Distributed real-time systems are becoming more pervasive in many domains including process control, discrete manufacturing, defense systems, air traffic control, and on-line monitoring systems in medicine. The construction of such systems, however, is impeded by the lack of simple yet powerful programming models and the lack of efficient, scalable, dependable and analyzable interfaces and their implementations. We argue that these issues need to be resolved with powerful application-level toolkits similar to that provided by ISIS [2]. In this paper, we consider the inter-process communication requirements which form a fundamental block in the construction of distributed real-time systems. We propose the real-time publisher/subscriber model, a variation of group-based programming and anonymous communication techniques, as a model for distributed real-time inter-process communication which can address issues of programming ease, portability, scalability and analyzability. The model has been used successfully in building a software architecture for building upgradable real-time systems. We provide the programming interface, a detailed design and implementation details of this model along with some preliminary performance benchmarks. The results are encouraging in that the goals we seek look achievable.},
author = {Rajkumar, Ragunathan and Gagliardi, Mike and Sha, Lui},
booktitle = {Real-Time Technology and Applications - Proceedings},
doi = {10.1109/RTTAS.1995.516203},
isbn = {0-8186-6980-2},
issn = {10801812},
keywords = {Benchmarking,Communication,Computer debugging,Computer hardware,Computer prog,Real time systems,Scala},
title = {{Real-time publisher/subscriber inter-process communication model for distributed real-time systems: design and implementation}},
year = {1995}
}
@incollection{buttazzo1995adding,
author = {Buttazzo, Giorgio C and Stankovic, John A},
booktitle = {Responsive Computer Systems: Steps Toward Fault-Tolerant Real-Time Systems},
pages = {67--88},
publisher = {Springer},
title = {{Adding robustness in dynamic preemptive scheduling}},
year = {1995}
}
@article{Bershad1995,
abstract = {Application domains such as multimedia, databases, and parallel computing, require operating system services with high performance and high functionality. Existing operating systems provide fixed interfaces and implementations to system services and resources. This makes them inappropriate for applications whose resource demands and usage patterns are poorly matched by the services provided. The SPIN operating system enables system services to be defined in an application-specific fashion through an extensible microkernel. It offers applications fine-grained control over a machine's logical and physical resources through run-time adaptation of the system to application requirements.},
author = {Bershad, Brian N. and Chambers, Craig and Eggers, Susan and Maeda, Chris and McNamee, Dylan and Pardyak, Przemys{\l}aw and Savage, Stefan and Sirer, Emin G{\"{u}}n},
doi = {10.1145/202453.202472},
issn = {01635980},
journal = {ACM SIGOPS Operating Systems Review},
title = {{{\textless}i{\textgreater}SPIN{\textless}/i{\textgreater} ---an extensible microkernel for application-specific operating system services}},
year = {1995}
}
@article{koren1995d,
author = {Koren, Gilad and Shasha, Dennis},
journal = {SIAM Journal on Computing},
number = {2},
pages = {318--339},
publisher = {SIAM},
title = {{D{\^{}}over: An Optimal On-Line Scheduling Algorithm for Overloaded Uniprocessor Real-Time Systems}},
volume = {24},
year = {1995}
}
@article{barabanov1997linux,
author = {Barabanov, Michael},
publisher = {New Mexico Institute of Mining and Technology Socorro, New Mexico},
title = {{A linux-based real-time operating system}},
year = {1997}
}
@inproceedings{Tezuka1998,
author = {Tezuka, Hiroshi and O'Carroll, Francis and Hori, Atsushi and Ishikawa, Yutaka},
booktitle = {Proceedings of the 1st Merged International Parallel Processing Symposium and Symposium on Parallel and Distributed Processing, IPPS/SPDP 1998},
doi = {10.1109/IPPS.1998.669932},
isbn = {0818684038},
issn = {10637133},
title = {{Pin-down cache: A virtual memory management technique for zero-copy communication}},
year = {1998}
}
@inproceedings{Stankovic1999,
abstract = {Despite the significant body of results in real-time scheduling,$\backslash$nmany real world problems are not easily supported. While algorithms such$\backslash$nas Earliest Deadline First, Rate Monotonic, and the Spring scheduling$\backslash$nalgorithm can support sophisticated task set characteristics (such as$\backslash$ndeadlines, precedence constraints, shared resources, jitter, etc.), they$\backslash$nare all {\&}ldquo;open loop{\&}rdquo; scheduling algorithms. Open loop refers$\backslash$nto the fact that once schedules are created they are not$\backslash$n{\&}ldquo;adjusted{\&}rdquo; based on continuous feedback. While open-loop$\backslash$nscheduling algorithms can perform well in static or dynamic systems in$\backslash$nwhich the workloads can be accurately modeled, they can perform poorly$\backslash$nin unpredictable dynamic systems. In this paper, we present a new$\backslash$nscheduling paradigm, which we call feedback control real-time$\backslash$nscheduling. Feedback control real-time scheduling defines error terms$\backslash$nfor schedules, monitors the error, and continuously adjusts the$\backslash$nschedules to maintain stable performance. This paper also presents a$\backslash$npractical feedback control real-time scheduling algorithm, FC-EDF, which$\backslash$nis a starting point in the long-term endeavor of creating a theory and$\backslash$npractice of feedback control scheduling},
author = {Stankovic, J. A. and Lu, Chenyang and Son, S. H. and Tao, Gang},
booktitle = {Proceedings - Euromicro Conference on Real-Time Systems},
doi = {10.1109/EMRTS.1999.777445},
isbn = {0769502407},
issn = {10683070},
title = {{The case for feedback control real-time scheduling}},
year = {1999}
}
@article{ONeil1999,
abstract = {This paper analyzes a recently published algorithm for page replacement in hierarchical paged memory systems [O'Neil et al. 1993], The algorithm is called the LRU-K method, and reduces to the well-known LRU (Least Recently Used) method for K = 1. Previous work [O'Neil et al. 1993; Weikum et al. 1994; Johnson and Shasha 1994]  has shown the effectiveness for K  {\textgreater}  1 by simulation, especially in the most common case of K = 2. The basic idea in LRU-K is to keep track of the times of the last K references to memory pages, and to use this statistical information to rank-order the pages as to their expected future behavior. Based on this the page replacement policy decision is made: which memory-resident page to replace when a newly accessed page must be read into memory. In the current paper, we prove, under the assumptions of the independent reference model, that LRU-K is optimal. Specifically we show: given the times of the (up to) K most recent references to each disk page, no other algorithm A making decisions to keep pages in a memory buffer holding n - 1 pages based on this information can improve on the expected number of I/Os to access pages over the LRU-K algorithm using a memory buffer holding n pages. The proof uses the Bayesian formula to relate the space of actual page probabilities of the model to the space of observable page numbers on which the replacement decision is actually made.},
author = {O'Neil, Elizabeth J. and O'Neil, Patrick E. and Weikum, Gerhard},
doi = {10.1145/300515.300518},
issn = {00045411},
journal = {J. ACM},
title = {{An optimality proof of the LRU-K page replacement algorithm}},
year = {1999}
}
@inproceedings{Gaspar2001,
abstract = {The real-time systems of HEP experiments are presently highly distributed, possibly on heterogeneous CPUs. In many applications, there is an important need to make information available to a large number of other processes in a transparent way. For this purpose the "RPC-like" systems are not itable, since most of them rely on polling from the client and one-to-one connections. DIM is a very powerful alternative to those systems. It provides a named space for processes to publish information (Publishers) and a very simple API for processes willing to use this information (Subscribers). It fully handles error recovery at the Publisher and Subscriber level, without additional software in the application. DIM is available on a large variety of platforms and operating systems with C and C++ bindings. It is presently used in several HEP experiments, while it was developed in the DELPHI experiment and is maintained at CERN. We shall present its capabilities and examples of its use in HEP experiments in domains ranging from simple data publishing to event transfer, process control or communication layer for an Experiment Control Package (SMI++). We shall also present prospectives for using it as communications layer for future experiment's control systems. {\textcopyright} 2001 Elsevier Science B.V. All rights reserved.},
author = {Gaspar, C. and D{\"{o}}nszelmann, M. and Charpentier, Ph},
booktitle = {Computer Physics Communications},
doi = {10.1016/S0010-4655(01)00260-0},
issn = {00104655},
keywords = {Asynchronous communications,Heterogeneous distributed systems},
title = {{DIM, a portable, light weight package for information publishing, data transfer and inter-process communication}},
year = {2001}
}
@article{ip2001performance,
author = {Ip, Benjamin},
journal = {Languages of Embedded Systems Department of Computer Science},
title = {{Performance analysis of vxworks and rtlinux}},
year = {2001}
}
@article{Zuberi2001,
abstract = {EMERALDS (Extensible Microkernel for Embedded, ReAL-time,$\backslash$nDistributed Systems) is a real-time microkernel designed for$\backslash$nsmall-memory embedded applications. These applications must run on slow$\backslash$n(15-25 MHz) processors with just 32-128 kbytes of memory, either to keep$\backslash$nproduction costs down in mass produced systems or to keep weight and$\backslash$npower consumption low. To be feasible for such applications, the OS must$\backslash$nnot only be small in size (less than 20 kbytes), but also have low$\backslash$noverhead kernel services. Unlike commercial embedded OSs which rely on$\backslash$ncarefully optimized code to achieve efficiency, EMERALDS takes the$\backslash$napproach of redesigning the basic OS services of task scheduling,$\backslash$nsynchronization, communication, and system call mechanism by using$\backslash$ncharacteristics found in small-memory embedded systems, such as small$\backslash$ncode size and a priori knowledge of task execution and communication$\backslash$npatterns. With these new schemes, the overheads of various OS services$\backslash$nare reduced 20-40 percent without compromising any OS$\backslash$nfunctionality},
author = {Zuberi, Khawar M. and Shin, Kang G.},
doi = {10.1109/32.962561},
isbn = {0-7695-0306-3},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Embedded systems,Intertask communication,Real-time operating systems,Real-time scheduling,Task synchronization},
title = {{EMERALDS: A small-memory real-time microkernel}},
year = {2001}
}
@inproceedings{sundell2002noble,
author = {Sundell, H{\aa}kan and Tsigas, Philippas},
booktitle = {Proceedings of the 6th Workshop on Languages, Compilers and Run-time Systems for Scalable Computers},
title = {{NOBLE: A non-blocking inter-process communication library}},
year = {2002}
}
@inproceedings{Unsal2003,
abstract = { Power and energy consumption has recently become an important issue and consequently, power-aware techniques are being devised at all levels of system design; from the circuit and device level, to the architectural, compiler, operating system, and networking layers. In this paper, we concentrate on power-aware design techniques for real-time systems. While the main focus is on hard real-time, soft real-time systems are considered as well. We start with the motivation for focusing on these systems and provide a brief discussion on power and energy objectives. We then follow with a survey of current research on a layer-by-layer basis. We conclude with illustrative examples and open research challenges. This paper provides an overview of power-aware techniques for the real-time system engineer as well as an up-to-date reference list for the researcher.},
author = {Unsal, Osman S. and Koren, Israel},
booktitle = {Proceedings of the IEEE},
doi = {10.1109/JPROC.2003.814617},
isbn = {0018-9219},
issn = {00189219},
keywords = {Compiler,Microarchitecture,Network,Operating system,Power-aware design,Real-time systems},
title = {{System-level power-aware design techniques in real-time systems}},
year = {2003}
}
@book{englander2003architecture,
author = {Englander, Irv and Englander, Arv},
publisher = {Wiley},
title = {{The architecture of computer hardware and systems software: an information technology approach}},
year = {2003}
}
@misc{yodaiken2004against,
author = {Yodaiken, Victor},
title = {{Against priority inheritance}},
year = {2004}
}
@article{Buttazzo2005,
abstract = {Since the first results published in 1973 by Liu and Layland on the Rate Monotonic (RM) and Earliest Deadline First (EDF) algorithms, a lot of progress has been made in the schedulability analysis of periodic task sets. Unfortunately, many misconceptions still exist about the properties of these two scheduling methods, which usually tend to favor RM more than EDF. Typical wrong statements often heard in technical conferences and even in research papers claim that RM is easier to analyze than EDF, it introduces less runtime overhead, it is more predictable in overload conditions, and causes less jitter in task execution. Since the above statements are either wrong, or not precise, it is time to clarify these issues in a systematic fashion, because the use of EDF allows a better exploitation of the available resources and significantly improves system's performance. This paper compares RM against EDF under several aspects, using existing theoretical results, specific simulation experiments, or simple counterexamples to show that many common beliefs are either false or only restricted to specific situations.},
author = {Buttazzo, Giorgio C.},
doi = {10.1023/B:TIME.0000048932.30002.d9},
isbn = {0922-6443},
issn = {09226443},
journal = {Real-Time Systems},
keywords = {Earliest Deadline First,Misconceptions,Overload,Periodic task,Rate Monotonic,Real-time scheduling},
pmid = {6148336},
title = {{Rate Monotonic vs. EDF: Judgment day}},
year = {2005}
}
@inproceedings{Kirsch2005,
abstract = {We present a new software system architecture for the implementation$\backslash$nof hard real-time applications. The core of the system is a microkernel$\backslash$nwhose reactivity (interrupt handling as in synchronous reactive programs)$\backslash$nand proactivity (task scheduling as in traditional RTOSs) are fully$\backslash$nprogrammable. The microkernel, which we implemented on a Strong-ARM$\backslash$nprocessor, consists of two interacting domain-specific virtual machines,$\backslash$na reactive E (Embedded) machine and a proactive S (Scheduling) machine.$\backslash$nThe microkernel code (or microcode) that runs on the microkernel$\backslash$nis partitioned into E and S code. E code manages the interaction$\backslash$nof the system with the physical environment: the execution of E code$\backslash$nis triggered by environment interrupts, which signal external events$\backslash$nsuch as the arrival of a message or sensor value, and it releases$\backslash$napplication tasks to the S machine. S code manages the interaction$\backslash$nof the system with the processor: the execution of S code is triggered$\backslash$nby hardware interrupts, which signal internal events such as the$\backslash$ncompletion of a task or time slice, and it dispatches application$\backslash$ntasks to the CPU, possibly preempting a running task. This partition$\backslash$nof the system orthogonalizes the two main concerns of real-time implementations:$\backslash$nE code refers to environment time and thus defines the reactivity$\backslash$nof the system in a hardware- and scheduler-independent fashion; S$\backslash$ncode refers to CPU time and defines a system scheduler. If both time$\backslash$nlines can be reconciled, then the code is called time safe; violations$\backslash$nof time safety are handled again in a programmable way, by run-time$\backslash$nexceptions. The separation of E from S code permits the independent$\backslash$nprogramming, verification, optimization, composition, dynamic adaptation,$\backslash$nand reuse of both reaction and scheduling mechanisms. Our measurements$\backslash$nshow that the system overhead is very acceptable even for large sets$\backslash$nof task, generally in the 0.2–0.3{\%} range.},
author = {Kirsch, Christoph Meyer and Sanvido, Marco A A and Henzinger, Thomas A},
booktitle = {Proceedings of the 1st International Conference on Virtual Execution Environments (VEE)},
doi = {10.1145/1064979.1064986},
isbn = {1595930477},
title = {{A Programmable Microkernel for Real-Time Systems}},
year = {2005}
}
@inproceedings{Barbalace2008,
abstract = {We report on a set of performance measurements executed on VMEbus MVME5500 boards equipped with MPC7455 PowerPC processor, running four different operating systems: Wind River VxWorks, Linux, RTAI, and Xenomai. Some components of RTAI and Xenomai have been ported to the target architecture. Interrupt latency, rescheduling and inter-process communication times are compared in the framework of a sample real-time application. Performance measurements on Gigabit Ethernet network communication have also been carried out on the target boards. To this purpose, we have considered the Linux IP stack and RTnet, an open-source hard real-time network protocol stack for Xenomai and RTAI, which was ported to the considered architecture. Performance measurements show that the tested open-source software is suitable for hard real-time applications.},
author = {Barbalace, A. and Luchetta, A. and Manduchi, G. and Moro, M. and Soppelsa, A. and Taliercio, C.},
booktitle = {IEEE Transactions on Nuclear Science},
doi = {10.1109/TNS.2007.905231},
isbn = {1424408679},
issn = {00189499},
keywords = {ADEOS,Linux,PowerPC,RTAI,RTnet,Real-time systems,VxWorks,Xenomai},
title = {{Performance comparison of VxWorks, Linux, RTAI, and Xenomai in a hard real-time application}},
year = {2008}
}
@book{burns2009real,
author = {Burns, Alan and Wellings, Andy},
publisher = {Addison-Wesley Educational Publishers Inc},
title = {{Real-Time Systems and Programming Languages: Ada, Real-Time Java and C/Real-Time POSIX}},
year = {2009}
}
@inproceedings{Aroca2009,
abstract = {This article presents quantitative and qualitative results obtained from the analysis of real time operating systems (RTOS). The studied systems were Windows CE, QNX Neutrino, VxWorks, Linux and RTAI-Linux, which are largely used in industrial and academic environments. Windows XP was also analysed, as a reference for conventional non-real-time operating system, since such systems are also commonly and inadvertently used for instrumentation and control purposes. The evaluations include worst case response times for latency, latency jitter and response time.},
author = {Aroca, Rafael V and Caurin, Glauco},
booktitle = {WSO - Workshop de Sistemas Operacionais},
title = {{A Real Time Operating Systems (RTOS) Comparison}},
year = {2009}
}
@book{buttazzo2011hard,
author = {Buttazzo, Giorgio C},
publisher = {Springer Science {\&} Business Media},
title = {{Hard real-time computing systems: predictable scheduling algorithms and applications}},
volume = {24},
year = {2011}
}
@article{chavan2011comparison,
author = {Chavan, Amit S and Nayak, Kartik R and Vora, Keval D and Purohit, Manish D and Chawan, Pramila M},
journal = {International Journal of Engineering and Technology},
number = {2},
pages = {171},
publisher = {IACSIT Press},
title = {{A comparison of page replacement algorithms}},
volume = {3},
year = {2011}
}
@misc{dodge2013process,
annote = {US Patent 8,434,086},
author = {Dodge, Dan and Danko, Attilla and Marineau-Mes, Sebastien and {Van Der Veen}, Peter and Burgess, Colin and Fletcher, Thomas and Stecher, Brian},
publisher = {Google Patents},
title = {{Process scheduler employing adaptive partitioning of process threads}},
year = {2013}
}
@article{Matsakis2014,
abstract = {NMR data on lipid hydroperoxides is scarce. In this study, hydroperoxides were produced from methyl 9-cis,11-trans-octadecadienoate and from methyl 10-trans,12-cis-octadecadienoate by autoxidation in the presence of 20{\%} of alpha-tocopherol. Ten different hydroperoxides were isolated from the autoxidation mixtures of the two conjugated linoleic acid (CLA) methyl esters by SPE and HPLC. The assignment of the 1H and 13C NMR spectra of these hydroperoxides was accomplished by 2D NMR experiments and by spectral simulations. Substitution of a hydroperoxyl group at the allylic position in CLA methyl esters induced a 53.93 ppm downfield shift on the hydroperoxyl-bearing carbon resonance. The effects on the olefinic alpha, beta, gamma, and delta carbon resonances were -3.45, +4.96, -1.22, and +4.42 ppm, respectively. Furthermore, the solvent effects of deuterochloroform, deuteroacetone, and deuterobenzene on the 13C resonances of the hydroperoxides suggest that deuterochloroform is the appropriate solvent for 13C NMR studies on mixtures of lipid hydroperoxides.},
author = {Matsakis, Nicholas D. and Klock, Felix S.},
doi = {10.1145/2692956.2663188},
isbn = {9781450332170},
issn = {10943641},
journal = {ACM SIGAda Ada Letters},
pmid = {18534191},
title = {{The rust language}},
year = {2014}
}
@article{Nelson2014,
abstract = {The functionality of embedded systems is ever increasing. This has lead to mixed time-criticality systems, where applications with a variety of real-time requirements co-exist on the same platform and share resources. Due to inter-application interference, verifying the real-time requirements of such systems is generally non trivial. In this paper, we present the CoMik microkernel that provides temporally predictable and composable processor virtualisation. CoMik's virtual processors are cycle-accurately composable, i.e. their timing cannot affect the timing of co-existing virtual processors by even a single cycle. Real-time applications executing on dedicated virtual processors can therefore be verified and executed in isolation, simplifying the verification of mixed time-criticality systems. We demonstrate these properties through experimentation on an FPGA prototyped hardware platform.},
author = {Nelson, Andrew and Nejad, Ashkan Beyranvand and Molnos, Anca and Koedam, Martijn and Goossens, Kees},
doi = {10.7873/DATE2014.235},
isbn = {9783981537024},
issn = {15301591},
journal = {DATE},
title = {{CoMik : A Predictable and Cycle-Accurately Composable Real-Time Microkernel}},
year = {2014}
}
@inproceedings{Anderson2016,
abstract = {All modern web browsers - Internet Explorer, Firefox, Chrome, Opera, and Safari - have a core rendering engine written in C++. This language choice was made because it affords the systems programmer complete control of the underlying hardware features and memory in use, and it provides a transparent compilation model. Unfortunately, this language is complex (especially to new contributors!), challenging to write correct parallel code in, and highly susceptible to memory safety issues that potentially lead to security holes. Servo is a project started at Mozilla Research to build a new web browser engine that preserves the capabilities of these other browser engines but also both takes advantage of the recent trends in parallel hardware and is more memory-safe. We use a new language, Rust, that provides us a similar level of control of the underlying system to C++ but which statically prevents many memory safety issues and provides direct support for parallelism and concurrency. In this paper, we show how a language with an advanced type system can address many of the most common security issues and software engineering challenges in other browser engines, while still producing code that has the same performance and memory profile. This language is also quite accessible to new open source contributors and employees, even those without a background in C++ or systems programming. We also outline several pitfalls encountered along the way and describe some potential areas for future improvement.},
author = {Anderson, Brian and Bergstrom, Lars and Goregaokar, Manish and Matthews, Josh and McAllister, Keegan and Moffitt, Jack and Sapin, Simon},
booktitle = {Proceedings of the 38th International Conference on Software Engineering Companion - ICSE '16},
doi = {10.1145/2889160.2889229},
isbn = {9781450342056},
issn = {02705257},
title = {{Engineering the servo web browser engine using Rust}},
year = {2016}
}
@article{heldring2018rtos,
author = {Heldring, Wicher},
title = {{An RTOS for embedded sys-tems in Rust}},
year = {2018}
}
